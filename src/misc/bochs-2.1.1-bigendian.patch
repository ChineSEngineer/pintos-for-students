The third patch makes the gdb stubs work on Solaris/Sparc, by doing
proper byteswapping.  It should be harmless elsewhere.

diff -urp orig/bochs-2.1.1/gdbstub.cc bochs-2.1.1/gdbstub.cc
--- orig/bochs-2.1.1/gdbstub.cc	2004-02-11 14:28:41.000000000 -0800
+++ bochs-2.1.1/gdbstub.cc	2004-09-13 16:41:59.652988000 -0700
@@ -474,11 +475,13 @@ static void debug_loop(void)
           case 'P':
               {
                  int reg;
-                 int value;
+                 Bit8u vbits[4];
+                 Bit32u value;
                  char* ebuf;
                  
                  reg = strtoul(&buffer[1], &ebuf, 16);
-                 value = ntohl(strtoul(ebuf + 1, &ebuf, 16));
+                 hex2mem(ebuf + 1, vbits, sizeof value);
+                 ReadHostDWordFromLittleEndian(vbits, value);
                  
                  BX_INFO (("reg %d set to %x", reg, value));
                  
@@ -527,35 +530,36 @@ static void debug_loop(void)
               }
             
           case 'g':
-            registers[0] = EAX;
-            registers[1] = ECX;
-            registers[2] = EDX;
-            registers[3] = EBX;
-            registers[4] = ESP;
-            registers[5] = EBP;
-            registers[6] = ESI;
-            registers[7] = EDI;
+            WriteHostDWordToLittleEndian(registers + 0, EAX);
+            WriteHostDWordToLittleEndian(registers + 1, ECX);
+            WriteHostDWordToLittleEndian(registers + 2, EDX);
+            WriteHostDWordToLittleEndian(registers + 3, EBX);
+            WriteHostDWordToLittleEndian(registers + 4, ESP);
+            WriteHostDWordToLittleEndian(registers + 5, EBP);
+            WriteHostDWordToLittleEndian(registers + 6, ESI);
+            WriteHostDWordToLittleEndian(registers + 7, EDI);
             if (last_stop_reason == GDBSTUB_EXECUTION_BREAKPOINT)
               {
-                 registers[8] = EIP + 1;
+                WriteHostDWordToLittleEndian(registers + 8, EIP + 1);
               }
             else
               {
-                 registers[8] = EIP;
+                WriteHostDWordToLittleEndian(registers + 8, EIP);
               }
-            registers[9] = BX_CPU_THIS_PTR read_eflags();
-            registers[10] = 
-              BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value;
-            registers[11] = 
-              BX_CPU_THIS_PTR sregs[BX_SEG_REG_SS].selector.value;
-            registers[12] = 
-              BX_CPU_THIS_PTR sregs[BX_SEG_REG_DS].selector.value;
-            registers[13] = 
-              BX_CPU_THIS_PTR sregs[BX_SEG_REG_ES].selector.value;
-            registers[14] = 
-              BX_CPU_THIS_PTR sregs[BX_SEG_REG_FS].selector.value;
-            registers[15] = 
-              BX_CPU_THIS_PTR sregs[BX_SEG_REG_GS].selector.value;
+            WriteHostDWordToLittleEndian(registers + 9,
+                                         BX_CPU_THIS_PTR read_eflags());
+            WriteHostDWordToLittleEndian(registers + 10,
+              BX_CPU_THIS_PTR sregs[BX_SEG_REG_CS].selector.value);
+            WriteHostDWordToLittleEndian(registers + 11,
+              BX_CPU_THIS_PTR sregs[BX_SEG_REG_SS].selector.value);
+            WriteHostDWordToLittleEndian(registers + 12,
+              BX_CPU_THIS_PTR sregs[BX_SEG_REG_DS].selector.value);
+            WriteHostDWordToLittleEndian(registers + 13,
+              BX_CPU_THIS_PTR sregs[BX_SEG_REG_ES].selector.value);
+            WriteHostDWordToLittleEndian(registers + 14,
+              BX_CPU_THIS_PTR sregs[BX_SEG_REG_FS].selector.value);
+            WriteHostDWordToLittleEndian(registers + 15,
+              BX_CPU_THIS_PTR sregs[BX_SEG_REG_GS].selector.value);
             mem2hex((char *)registers, obuf, NUMREGSBYTES);
             put_reply(obuf);
             break;

