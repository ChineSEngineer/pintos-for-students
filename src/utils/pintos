#! /usr/bin/perl -w

use strict;
use POSIX;

our ($mem) = 4;
our ($serial_out) = 1;
our ($disk) = "pintos.dsk";
our (@part_files) = ("boot.part", "filesys.part", "scratch.part", "swap.part");
our ($sim);
our ($debug);
our ($vga);
our ($jitter, $realtime);

our (%role2type) = (0 => 0x20, 1 => 0x21, 2 => 0x22, 3 => 0x23);

use Getopt::Long qw(:config require_order bundling);
unshift (@ARGV, split (' ', $ENV{PINTOSOPTS}))
  if defined $ENV{PINTOSOPTS};
GetOptions ("sim=s" => sub { set_sim (@_) },
	    "bochs" => sub { set_sim ("bochs") },
	    "qemu" => sub { set_sim ("qemu") },
	    "gsx" => sub { set_sim ("gsx") },

	    "debug=s" => sub { set_debug (@_) },
	    "no-debug" => sub { set_debug ("no-debug") },
	    "monitor" => sub { set_debug ("monitor") },
	    "gdb" => sub { set_debug ("gdb") },

	    "run|get|put|assemble|disassemble" => \&cmd_option,

	    "m|memory=i" => \$mem,
	    "j|jitter=i" => sub { set_jitter (@_) },
	    "r|realtime" => sub { set_realtime () },

	    "v|no-vga" => sub { set_vga ('none'); },
	    "s|no-serial" => sub { $serial_out = 0; },
	    "t|terminal" => sub { set_vga ('terminal'); },

	    "h|help" => sub { usage (0); },

	    "disk=s" => \$disk,

	    "boot-partition=s" => \$part_files[0],
	    "fs-partition|filesys-partition=s" => \$part_files[1],
	    "scratch-partition=s" => \$part_files[2],
	    "swap-partition=s" => \$part_files[3]
	   )
  or exit 1;

$sim = "bochs" if !defined $sim;
$debug = "no-debug" if !defined $debug;
$vga = "window" if !defined $vga;

sub set_sim {
    my ($new_sim) = @_;
    die "--$new_sim conflicts with --$sim\n"
      if defined ($sim) && $sim ne $new_sim;
    $sim = $new_sim;
}

sub set_debug {
    my ($new_debug) = @_;
    die "--$new_debug conflicts with --$debug\n"
      if defined ($debug) && $debug ne $new_debug;
    $debug = $new_debug;
}

sub set_vga {
    my ($new_vga) = @_;
    if (defined ($vga) && $vga ne $new_vga) {
	print "warning: conflicting vga display options\n";
    }
    $vga = $new_vga;
}

sub set_jitter {
    my ($new_jitter) = @_;
    die "--realtime conflicts with --jitter\n" if defined $realtime;
    die "different --jitter already defined\n"
      if defined $jitter && $jitter != $new_jitter;
    $jitter = $new_jitter;
}

sub set_realtime {
    die "--realtime conflicts with --jitter\n" if defined $jitter;
    $realtime = 1;
}

sub cmd_option {
    # Force an end to option processing, as with --.
    die ("!FINISH");
}

die "no command specified; use --help for help\n"
  if @ARGV < 1;
my ($cmd) = shift @ARGV;
if ($cmd eq 'run') {
    run_vm (@ARGV);
} elsif ($cmd eq 'put') {
    # Take a -f option to combine formatting with putting.
    my ($format) = 0;
    if (@ARGV > 0 && $ARGV[0] eq '-f') {
	shift @ARGV;
	$format = 1;
    }

    usage () if @ARGV != 1 && @ARGV != 2;
    my ($hostfn, $guestfn) = @ARGV;
    $guestfn = $hostfn if !defined $guestfn;

    # Disassemble.
    @part_files = ("part0.tmp", "part1.tmp", "part2.tmp", "part3.tmp");
    disassemble ($part_files[0], $part_files[1], undef, $part_files[3]);
    die "missing file system partition\n" if ! -e $part_files[1];

    # Create scratch disk from file.
    open (FILE, "<$hostfn") or die "$hostfn: open: $!\n";
    my ($scratchfn) = $part_files[1];
    open (SCRATCH, ">$scratchfn") or die "$scratchfn: create: $!\n";
    my ($size) = 0;
    for (;;) {
	my ($buf);
	my ($amt) = sysread (FILE, $buf, 65536);
	die "$hostfn: read: $!\n" if $amt < 0;
	last if $amt == 0;
	syswrite (FILE, $buf, $amt) == $amt or die "$scratchfn: write: $!\n";
	$size += $amt;
    }
    my ($zeros) = 512 - $size % 512;
    syswrite (FILE, "\0" x $zeros) == $zeros or die "$scratchfn: write: $!\n";
    close (SCRATCH);
    close (FILE);

    # Reassemble.
    assemble ();
    unlink (@part_files);

    # Do copy.
    my (@cmd) = ("-ci", $guestfn, $size, "-q");
    unshift (@cmd, "-f") if $format;
    run_vm (@cmd);
} elsif ($cmd eq 'get') {
    usage () if @ARGV != 1 && @ARGV != 2;
    my ($guestfn, $hostfn) = @ARGV;
    $hostfn = $guestfn if !defined $hostfn;
    die "$hostfn: already exists\n" if -e $hostfn;

    # Disassemble.
    @part_files = ("part0.tmp", "part1.tmp", undef, "part3.tmp");
    disassemble (@part_files);

    # Create scratch disk big enough for any file in the file system
    # (modulo sparse files).
    die "missing file system partition\n" if ! -e $part_files[1];
    my ($fs_size) = -s _;
    my ($approx_mb) = (16 * 63 * 512) * 2;
    $part_files[2] = sprintf ("%d",
			      int (($fs_size + $approx_mb - 1) / $approx_mb));
    assemble (@part_files);

    # Do copy.
    run_vm ("-co", $guestfn, "-q");

    # FIXME: we could just read the parttbl, then copy directly.
    # Disassemble.
    my ($scratchfn) = "part2.tmp";
    disassemble (undef, undef, $scratchfn, undef);

    # Read out scratch disk.
    print "copying $guestfn from $scratchfn to $hostfn...\n";
    open (SRC, "<$scratchfn") or die "$scratchfn: open: $!\n";
    open (DST, ">$hostfn") or die "$hostfn: create: $!\n";
    my ($input);
    read (SRC, $input, 512) == 512 or die "$scratchfn: read error\n";
    my ($size) = unpack ("V", $input);
    $size != 0xffffffff or die "$guestfn: too big for $scratchfn?";
    my ($src);
    read (SRC, $src, $size) == $size or die "$scratchfn: read error\n";
    print DST $src or die "$hostfn: write error\n";
    close (DST);
    close (SRC);
} elsif ($cmd eq 'assemble') {
    die "$part_files[0] not found ($!), but a boot partition is required\n"
      if ! -e $part_files[0];
    do { $_ = undef if ! -e $_ } foreach @part_files[1...3];
    assemble ();
} elsif ($cmd eq 'help') {
    usage (0);
} else {
    die "unknown command `$cmd'; use --help for help\n";
}
exit 0;

sub usage {
    my ($exitcode) = @_;
    $exitcode = 1 unless defined $exitcode;
    print "pintos, a utility for invoking Pintos in a simulator\n";
    print "Usage: pintos [OPTION...] COMMAND [ARG...]\n";
    print "where COMMAND is one of the following:\n";
    print "  run [CMDLINE...]        run a VM in the simulator\n";
    print "  put HOSTFN [GUESTFN]    copy HOSTFN into VM (as GUESTFN)\n";
    print "  get GUESTFN [HOSTFN]    copy GUESTFN out of VM (to HOSTFN)\n";
    print "  assemble                assemble a VM disk from partitions\n";
    print "  disassemble             disassemble a VM disk into partitions\n";
    print "  help                    print this help message and exit\n";
    print "Simulator options:\n";
    print "  --bochs          (default) Use Bochs as simulator\n";
    print "  --qemu           Use qemu as simulator\n";
    print "  --gsx            Use VMware GSX Server 3.x as simulator\n";
    print "Debugger options:\n";
    print "  --no-debug       (default) No debugger\n";
    print "  --monitor        Debug with simulator's monitor\n";
    print "  --gdb            Debug with gdb\n";
    print "Display options: (default is VGA + serial)\n";
    print "  -v, --no-vga     No VGA display\n";
    print "  -s, --no-serial  No serial output\n";
    print "  -t, --terminal   Display VGA in terminal (Bochs only)\n";
    print "VM options:\n";
    print "  -d, --disk=DISK  File holding VM's disk (default: pintos.dsk)\n";
    print "  -j SEED          Randomize timer interrupts (Bochs only)\n";
    print "  -r, --realtime   Use realistic, but not reproducible, timings\n";
    print "  -m, --mem=MB     Run VM with MB megabytes of physical memory\n";
    print "Assemble/disassemble partitions (default names in parentheses):\n";
    print "(SOURCE is a file or a size in MB, for a blank partition.)\n";
    print "  --boot=FILE      Boot partition (boot.part)\n";
    print "  --filesys=SOURCE File system partition (filesys.part)\n";
    print "  --scratch=SOURCE Scratch partition (scratch.part)\n";
    print "  --swap=SOURCE    Swap partition (swap.part)\n";
    exit $exitcode;
}

sub copy_pad {
    my ($src, $dst, $blocksize) = @_;
    run_command ("dd", "if=$src", "of=$dst", "bs=$blocksize", "conv=sync");
}

sub create_disk {
    my ($disk, $kb) = @_;
    run_command ("dd", "if=/dev/zero", "of=$disk", "bs=1024", "count=$kb");
}

sub run_vm {
    my (@args) = @_;

    our ($disk);
    die "$disk: can't find OS disk\n" if ! -e $disk;

    # FIXME
    #     if (my ($project) = `pwd` =~ /\b(threads|userprog|vm|filesys)\b/) {
    # 	if ((grep ($project eq $_, qw (userprog vm filesys)))
    # 	    && !defined ($disks[1])) {
    # 	    print STDERR "warning: it looks like you're running the $project ";
    # 	    print STDERR "project, but no file system disk is present\n";
    # 	}
    # 	if ($project eq 'vm' && !defined $disks[3]) {
    # 	    print STDERR "warning: it looks like you're running the $project ";
    # 	    print STDERR "project, but no swap disk is present\n";
    # 	}
    #     }

    write_cmd_line ($disks[0], @args);

    if ($sim eq 'bochs') {
	my ($bin);
	if ($debug eq 'no-debug') {
	    $bin = 'bochs';
	} elsif ($debug eq 'monitor') {
	    $bin = 'bochs-dbg';
	} elsif ($debug eq 'gdb') {
	    $bin = 'bochs-gdb';
	}

	my ($bochsbin) = search_path ($bin);
	my ($bochsshare) = "$bochsbin/../share/bochs";

	open (BOCHSRC, ">bochsrc.txt") or die "bochsrc.txt: create: $!\n";
	print BOCHSRC "romimage: file=$bochsshare/BIOS-bochs-latest, "
	  . "address=0xf0000\n";
	print BOCHSRC "vgaromimage: $bochsshare/VGABIOS-lgpl-latest\n";
	print BOCHSRC bochs_disk_line ("ata0-master", $disks[0]);
	print BOCHSRC bochs_disk_line ("ata0-slave", $disks[1]);
	print BOCHSRC "ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15\n"
	  if defined ($disks[2]) || defined ($disks[3]);
	print BOCHSRC bochs_disk_line ("ata1-master", $disks[2]);
	print BOCHSRC bochs_disk_line ("ata1-slave", $disks[3]);
	print BOCHSRC "boot: c\n";
	print BOCHSRC "ips: 1000000\n";
	if (!$realtime) {
	    print BOCHSRC "clock: sync=none, time0=0\n";
	} else {
	    print BOCHSRC "clock: sync=realtime, time0=0\n";
	}
	print BOCHSRC "megs: $mem\n";
	print BOCHSRC "log: bochsout.txt\n";
	if ($vga ne 'terminal') {
	    print BOCHSRC "com1: enabled=1, dev=/dev/stdout\n"
	      if $serial_out;
	    print BOCHSRC "display_library: nogui\n"
	      if $vga eq 'none';
	} else {
	    print BOCHSRC "display_library: term\n";
	}
	close (BOCHSRC);

	my (@cmd) = ($bin, '-q');
	push (@cmd, '-j', $jitter) if defined $jitter;
	print join (' ', @cmd), "\n";
	my ($exit) = xsystem (@cmd);
	if (WIFEXITED ($exit)) {
	    # Bochs exited normally.
	    # Ignore the exit code; Bochs normally exits with status 1,
	    # which is weird.
	} elsif (WIFSIGNALED ($exit)) {
	    die "Bochs died with signal ", WTERMSIG ($exit), "\n";
	} else {
	    die "Bochs died: code $exit\n";
	}
    } elsif ($sim eq 'qemu') {
	print "warning: qemu doesn't support --terminal\n"
	  if $vga eq 'terminal';
	print "warning: qemu doesn't support jitter\n"
	  if defined $jitter;
	my (@cmd) = ('qemu');
	push (@cmd, '-hda', $disks[0]) if defined $disks[0];
	push (@cmd, '-hdb', $disks[1]) if defined $disks[1];
	push (@cmd, '-hdc', $disks[2]) if defined $disks[2];
	push (@cmd, '-hdd', $disks[3]) if defined $disks[3];
	push (@cmd, '-m', $mem);
	push (@cmd, '-nographic') if $vga eq 'none';
	push (@cmd, '-serial', 'stdio') if $serial_out && $vga ne 'none';
	push (@cmd, '-S') if $debug eq 'monitor';
	push (@cmd, '-s') if $debug eq 'gdb';
	run_command (@cmd);
    } elsif ($sim eq 'gsx') {
	print "warning: VMware GSX Server doesn't support --$debug\n"
	  if $debug ne 'no-debug';
	print "warning: VMware GSX Server doesn't support --no-vga\n"
	  if $vga eq 'none';
	print "warning: VMware GSX Server doesn't support --terminal\n"
	  if $vga eq 'terminal';
	print "warning: VMware GSX Server doesn't support jitter\n"
	  if defined $jitter;

	open (VMX, ">pintos.vmx") or die "pintos.vmx: create: $!\n";
	chmod 0777 & ~umask, "pintos.vmx";
	print VMX "#! /usr/bin/vmware -G\n";
	print VMX "config.version = 6\n";
	print VMX "guestOS = \"linux\"\n";
	print VMX "floppy0.present = FALSE\n";

	unlink ("pintos.out");
	print VMX "serial0.present = TRUE\n";
	print VMX "serial0.fileType = \"file\"\n";
	print VMX "serial0.fileName = \"pintos.out\"\n";

	if (! -e 'null.bin') {
	    open (NULL, ">null.bin") or die "null.bin: create: $!\n";
	    close (NULL);
	}

	for (my ($i) = 0; $i < 4; $i++) {
	    my ($dsk) = $disks[$i];
	    next if !defined $dsk;

	    my ($pln) = $dsk;
	    $pln =~ s/\.dsk//;
	    $pln .= ".pln";

	    my ($device) = "ide" . int ($i / 2) . ":" . ($i % 2);
	    print VMX "\n$device.present = TRUE\n";
	    print VMX "$device.deviceType = \"plainDisk\"\n";
	    print VMX "$device.fileName = \"$pln\"\n";

	    my (%geom) = disk_geometry ($dsk);
	    open (PLN, ">$pln") or die "$pln: create: $!\n";
	    print PLN "DRIVETYPE	ide\n";
	    print PLN "#vm|VERSION	2\n";
	    print PLN "#vm|TOOLSVERSION	2\n";
	    print PLN "CYLINDERS	$geom{C}\n";
	    print PLN "HEADS		$geom{H}\n";
	    print PLN "SECTORS		$geom{S}\n";
	    print PLN "#vm|CAPACITY	$geom{CAPACITY}\n";
	    print PLN "ACCESS \"$dsk\" 0 $geom{CAPACITY}\n";
	    close (PLN);
	}
	close (VMX);

	my ($vmx) = getcwd () . "/pintos.vmx";
	system ("vmware-cmd -s register $vmx >&/dev/null");
	system ("vmware-cmd $vmx stop hard >&/dev/null");
	system ("vmware -l -G -x -q $vmx");
	system ("vmware-cmd $vmx stop hard >&/dev/null");
    }
}

sub relay_signal {
    my ($pid, $signal) = @_;
    kill $signal, $pid;
    $SIG{$signal} = 'DEFAULT';
    kill $signal, getpid ();
}

sub xsystem {
    my ($pid) = fork;
    if (!defined ($pid)) {
	# Fork failed.
	die "fork: $!\n";
    } elsif (!$pid) {
	# Running in child process.
	exec (@_);
	exit (1);
    } else {
	# Running in parent process.
	local $SIG{INT} = sub { relay_signal ($pid, "INT"); };
	local $SIG{TERM} = sub { relay_signal ($pid, "TERM"); };
	waitpid ($pid, 0);
	return $?;
    }
}

sub write_cmd_line {
    my ($disk, @args) = @_;

    die "command line includes empty string" if grep (/^$/, @args);
    my ($args) = join ("\0", @args) . "\0\0";
    die "command line exceeds 128 bytes" if length ($args) > 128;
    $args .= "\0" x (128 - length ($args));

    print "writing command line to $disk...\n";
    open (DISK, "+<$disk") or die "$disk: open: $!\n";
    seek (DISK, 0x17e, 0) or die "$disk: seek: $!\n";
    syswrite (DISK, $args) or die "$disk: write: $!\n";
    close (DISK) or die "$disk: close: $!\n";
}

sub run_command {
    print join (' ', @_), "\n";
    die "command failed\n" if xsystem (@_);
}

sub search_path {
    my ($target) = @_;
    for my $dir (split (':', $ENV{PATH})) {
	return $dir if -e "$dir/$target";
    }
    die "$target not in PATH\n";
}

sub bochs_disk_line {
    my ($device, $file) = @_;
    return "" if !defined $file;
    my (%geom) = disk_geometry ($file);
    return ("$device: type=disk, path=$file, mode=flat, "
	    . "cylinders=$geom{C}, heads=$geom{H}, spt=$geom{S}, "
	    . "translation=none\n");
}

sub disk_geometry {
    my ($file) = @_;
    my ($size) = -s $file;
    die "$file: stat: $!\n" if !defined $size;
    die "$file: size not a multiple of 512 bytes\n" if $size % 512;
    my ($cylinders) = int ($size / (512 * 16 * 63));
    $cylinders++ if $size % (512 * 16 * 63);

    return (CAPACITY => $size / 512,
	    C => $cylinders,
	    H => 16,
	    S => 63);
}

sub assemble {
    my ($files) = @_;

    my (@parts);

    my (@part_names) = ("boot", "file system", "scratch", "swap");
    my ($next_start) = 1;
    for my $i (0..3) {
	my (%part);

	my ($name) = $part_names[$i];
	my ($file) = $files[$i];
	my ($size);
	if (-e $file) {
	    $size = -s _;
	} else {
	    if (($mb) = $file =~ /^\d+(\.\d+)?|\.\d+$/) {
		$size = $mb * 63 * 16 * 512;
		undef $file;
	    } else {
		die ("$file: stat: $!\n");
	    }
	}

	die "$name: not a multiple of 512 bytes in size\n"
	  if $size % 512;
	my ($sector_cnt) = $size / 512;
	my ($start) = $next_start;
	$next_start += $sector_cnt;

	push (@parts,
	      {ROLE => $i,
	       FILE => $file,
	       START = $start,
	       SECTORS => $sector_cnt});
    }
    die "Sorry, disk size (", ($sector_cnt * 512) / 1024 / 1024, " MB) "
      . "exceeds limit (approx. 503 MB)\n"
	if $sector_cnt > 1023 * 63 * 16;

    my ($part_tbl) = "\0" x 446;
    for my $p (@parts) {
	my ($bootable) = $p->{ROLE} == 0 ? 0x80 : 0x00;
	my (@start_chs) = linear_to_chs ($p->{START});
	my ($type) = $role2type{$p->{ROLE}};
	my (@end_chs) = linear_to_chs ($p->{START} + $p->{SECTORS} - 1);

	my ($part_tbl_entry) = pack ("C CCC C CCC V V",
				     $bootable,
				     pack_chs (@start_chs),
				     $type,
				     pack_chs (@end_chs),
				     $p->{START}, $p->{SECTORS});
	length ($part_tbl_entry) == 16 or die;
	$part_tbl .= $part_tbl_entry;
    }
    $part_tbl .= "\0" x 16 while length ($part_tbl) < 510;
    $part_tbl .= pack ("v", 0xaa55);
    length ($part_tbl) == 512 or die;

    our ($disk);
    open (DISK, ">$disk") or die "$disk: create: $!\n";
    syswrite (DISK, $part_tbl) == 512 or die "$disk: write: $!\n";

    for my $p (@parts) {
	$from_file = defined ($p->{FILE});
	open (PART, "<$p->{FILE}") or die "$p->{FILE}: open: $!\n"
	  if $from_file;

	my ($buf);
	for (my ($ofs) = 0; $ofs < $p->{SECTORS}; $ofs += length ($buf)) {
	    my ($bytes_left) = ($p->{SECTORS} - $ofs) * 512;
	    my ($read_bytes) = $bytes_left > 16384 ? 16384 : $bytes_left;

	    if ($from_file) {
		my ($ret) = sysread (PART, $buf, $read_bytes);
		die "$p->{FILE}: read: $!\n" if $ret < 0;
		die "$p->{FILE}: unexpected end of file\n"
		  if $ret != $read_bytes;
	    } else {
		$buf = "\0" x $read_bytes;
	    }

	    syswrite (DISK, $buf) == length ($buf)
	      or die "$p->{FILE}: write: $!\n"
	}

	close (PART) if $from_file;
    }

    close (DISK) or die "$disk: close: $!\n";
}

sub linear_to_chs {
    my ($linear) = @_;

    # We maintain these as constants.
    my ($heads) = 16;
    my ($sectors) = 63;
    my ($sectors_per_cylinder) = $heads * sectors;

    # Calculate C, H, S.
    my ($c) = int ($linear / $sectors_per_cylinder);
    my ($cylinder_ofs) = $linear % $sectors_per_cylinder;
    my ($h) = int ($cylinder_ofs / $sectors);
    my ($s) = $cylinder_ofs % $sectors;

    die if $c > 1023 || $h > 15 || $s > 63;

    return ($c, $h, $s);
}

sub pack_chs {
    my ($c, $h, $s) = @_;
    die if $c > 1023 || $h > 15 || $s > 63;

    my ($pc, $ph, $ps) = ($h, $s | (($c & 0x300) >> 2), $c & 0xff);
    die if $pc > 255 || $ph > 255 || ps > 255;

    return ($pc, $ph, $ps);
}

sub read_part_tbl {
    my ($part_tbl);
    open (DISK, "<$disk") or die "$disk: open: $!\n";
    sysread (DISK, $part_tbl, 512) == 512 or die "$disk: read: $!\n";
    close (DISK);

    my ($loader, @partitions, $signature);
    ($loader, @partitions[0..3], $signature)
      = unpack ("a446 (a16)4 v", $part_tbl);

    die "$disk: invalid partition table signature\n" if $signature != 0xaa55;

    my (@parts);
    for my $partition (@partitions) {
	my ($bootable, @start_chs_packed, $type, @end_chs_packed,
	    $start, $sector_cnt);
	($bootable, $start_chs_packed[0...2], $type, @end_chs_packed[0...2],
	 $start, $sector_cnt)
	  = unpack ("C CCC C CCC V V", $partition) or die;

	my ($role) = (reverse (%role2type{$type})){$type};
	next if !defined ($role);

	push (@parts,
	      {ROLE => $1,
	       START => $start,
	       SECTORS => $sector_cnt});
    }

    return @parts;
}

sub disassemble {
    my ($files) = @_;

    open (DISK, "<$disk") or die "$disk: open: $!\n";
    for my $p (read_part_tbl ()) {
	use Fcntl 'SEEK_CUR';

	my ($file) = $files[$p->{ROLE}];
	next if !defined $file;

	open (PART, ">$file") or die "$file: create: $!\n";
	sysseek (DISK, $p->{START} * 512, SEEK_CUR) or die "$disk: seek: $!\n";

	my ($buf);
	for (my ($ofs) = 0; $ofs < $p->{SECTORS}; $ofs += length ($buf)) {
	    my ($bytes_left) = ($p->{SECTORS} - $ofs) * 512;
	    my ($read_bytes) = $bytes_left > 16384 ? 16384 : $bytes_left;

	    my ($ret) = sysread (DISK, $buf, $read_bytes);
	    die "$p->{FILE}: read: $!\n" if $ret < 0;
	    die "$p->{FILE}: unexpected end of file\n"
	      if $ret != $read_bytes;

	    syswrite (PART, $buf) == length ($buf)
	      or die "$p->{FILE}: write: $!\n";
	}

	close (PART) or die "$file: close: $!\n";
    }
    close (DISK);
}
